{"version":3,"file":"index.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACDA;AAHA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACAA;AAIA;AAQA;AAIA;AAIA;AAIA;AAIA;AAxDA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;ACzDA;AAWA;AAaA;AA3BA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;ACjCA;AAFA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;;;;;;;ACAA;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":[".././src/index.ts",".././src/utils/command.ts",".././src/utils/log.ts",".././src/utils/unity.ts",".././src/utils/validate.ts","../external node-commonjs \"child_process\"","../external node-commonjs \"fs\"","../external node-commonjs \"path\"","../webpack/bootstrap","../webpack/runtime/compat","../webpack/before-startup","../webpack/startup","../webpack/after-startup"],"sourcesContent":["export * from \"./utils/command\";\nexport * from \"./utils/log\";\nexport * from \"./utils/unity\";\nexport * from \"./utils/validate\";\nexport * from \"./model/variable\";","import { spawn } from 'child_process';\nimport * as logging from './log';\n\nexport async function runCommand(command: string, args: string[]): Promise<number> {\n    let child = spawn(command, args)\n\n    child.stdout.pipe(process.stdout);\n    child.stderr.on('data', function(data) {\n        logging.logWithStyle('stderr: ' + data);\n    });\n\n    const waitOutputCompletion = new Promise<void>( (resolve, _) => {\n        child.stdout.on('end', () => {\n            resolve();\n        })\n    }); \n\n    return new Promise<number>((resolve, reject) => {\n        child.on('error', () => reject());\n        child.on('close', (code: number) => resolve(code));\n        child.on('exit', (code: number) => resolve(code));\n    })\n    .then(async (exit) => {\n        const timeoput = setTimeout(() => {}, 2000)\n        await Promise.any([\n            timeoput,\n            waitOutputCompletion\n        ])\n        return exit\n    });\n}","\n\nconst ColorReset = \"\\x1b[0m\";\n\nexport enum TextEffect {\n    Bright = \"\\x1b[1m\",\n    Dim = \"\\x1b[2m\",\n    Underscore = \"\\x1b[4m\",\n    Blink = \"\\x1b[5m\",\n    Reverse = \"\\x1b[7m\",\n    Hidden = \"\\x1b[8m\",\n    None = \"\"\n}\n\nexport enum ForegroundColor {\n    Black = \"\\x1b[30m\",\n    Red = \"\\x1b[31m\",\n    Green = \"\\x1b[32m\",\n    Yellow = \"\\x1b[33m\",\n    Blue = \"\\x1b[34m\",\n    Magenta = \"\\x1b[35m\",\n    Cyan = \"\\x1b[36m\",\n    White = \"\\x1b[37m\",\n}\n\nconst errorPrefix = \"::error::\"\nconst warningPrefix = \"::warning::\"\nconst startGroupPrefix = \"::group::\"\nconst endGroupPrefix = \"::endgroup::\"\n\nexport function log(message: string): void {\n    console.log(message);\n}\n\nexport function logWithStyle(\n    message: string, \n    color: ForegroundColor = ForegroundColor.White, \n    effect: TextEffect = TextEffect.None\n): void {\n    console.log(effect + color + message + ColorReset);\n}\n\nexport function error(message: string): void {\n    console.log(errorPrefix + message);\n}\n\nexport function startGroup(title: string): void {\n    console.log(startGroupPrefix + title);\n}\n\nexport function endGroup(message: string): void {\n    console.log(endGroupPrefix);\n}\n\nexport function warn(message: string): void {\n    console.log(warningPrefix + message);\n}\n\nexport function logLines(...args: string[]) {\n    console.log(args.join('\\n'));\n}","import { readFileSync, existsSync } from 'fs';\nimport { join, isAbsolute } from 'path';\n\nexport function getUnityPath(platform: string, version: string): string {\n    if (platform === 'windows') {\n        const unityFullPath = `C:\\\\Program Files\\\\Unity\\\\Hub\\\\Editor\\\\${version}\\\\Editor\\\\Unity.exe`;\n        if (existsSync(unityFullPath)) {\n            return unityFullPath;\n        }\n        else throw new Error(`Unity not found at ${unityFullPath}`);\n    }\n    throw new Error(`Unsupported platform. Please specify 'windows' as platform`);\n}\n\nexport function getUnityPathFromProject(platform: string, unityProjectPath: string): string {\n    const projectVersionFullPath = join(unityProjectPath, 'ProjectSettings', 'ProjectVersion.txt');\n\n    const data = readFileSync(projectVersionFullPath, { encoding: 'utf8' });\n    for (const line of data.split('\\n')) {\n        if (line.startsWith('m_EditorVersion:')) {\n            const version = line.split(':')[1].trim();\n            return getUnityPath(platform, version);\n        }\n    }\n    throw new Error('Unity version not found in ProjectVersion.txt');\n}\n\nexport function getUnityPathOrDefault(path: string, defaultPath: string): string {\n    if (!path) {\n        return defaultPath;\n    }\n\n    if (isAbsolute(path)) {\n        return path;\n    } else {\n        return join(defaultPath, path);\n    }\n}","import { Variables } from 'src/model/variable'\n\nlet _throw = (m: string) => {throw new Error(m)}\n\nexport function validateVariables(variables: Variables) {\n    Object.entries(variables).forEach(([key, value]) => {\n        if (value.value) {\n            return\n        }\n        if (value.mandatory) {\n            _throw(`Variable ${key} is mandatory`)\n        } else {\n            value.value = variables[key].default\n        }\n    })\n}","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(144);\n",""],"names":[],"sourceRoot":""}